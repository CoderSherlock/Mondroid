diff -uNr m1/Mondroid/kernelsource/msm/arch/arm64/configs/bullhead_defconfig m2/Mondroid/kernelsource/msm/arch/arm64/configs/bullhead_defconfig
--- m1/Mondroid/kernelsource/msm/arch/arm64/configs/bullhead_defconfig	2016-12-28 17:50:39.726330576 -0500
+++ m2/Mondroid/kernelsource/msm/arch/arm64/configs/bullhead_defconfig	2016-12-28 17:45:45.238786650 -0500
@@ -668,4 +668,12 @@
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
 CONFIG_QMI_ENCDEC=y
-CONFIG_STRICT_MEMORY_RWX=y
+# CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_FUNCTION_TRACER=y
+# CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_DYNAMIC_FTRACE=y
+# CONFIG_PERSISTENT_TRACER=y
+# CONFIG_IRQSOFF_TRACER=y
+# CONFIG_PREEMPT_TRACER=y
+# CONFIG_SCHED_TRACER=y
+# CONFIG_STACK_TRACER=y
diff -uNr m1/Mondroid/kernelsource/msm/fs/internal.h m2/Mondroid/kernelsource/msm/fs/internal.h
--- m1/Mondroid/kernelsource/msm/fs/internal.h	2016-12-28 17:50:39.746328037 -0500
+++ m2/Mondroid/kernelsource/msm/fs/internal.h	2016-12-28 17:46:13.585340667 -0500
@@ -141,3 +141,14 @@
  * pipe.c
  */
 extern const struct file_operations pipefifo_fops;
+
+/*
+ * HPZ: This is somthing in related
+ */
+
+#define FDMAX 100
+#define MEMMAX 1000
+extern int fd_list_p;
+extern int fd_list[100];
+extern int mem_pg_p;
+extern unsigned long mem_pg_list[1000];
diff -uNr m1/Mondroid/kernelsource/msm/fs/open.c m2/Mondroid/kernelsource/msm/fs/open.c
--- m1/Mondroid/kernelsource/msm/fs/open.c	2016-12-28 17:50:39.746328037 -0500
+++ m2/Mondroid/kernelsource/msm/fs/open.c	2016-12-28 17:46:13.729333219 -0500
@@ -917,6 +917,9 @@
 }
 EXPORT_SYMBOL(file_open_root);
 
+int fd_list_p = 0;
+int fd_list[100] = {0};
+
 long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
 {
 	struct open_flags op;
@@ -926,10 +929,18 @@
     /*
      * HPZ: Print out all open operation targets to a file start with "/data"
      */
-    char basename[5] = "/data";
-    if(memcmp(filename, basename, 5) == 0)
-        printk("[HPZ]\t%s is opened.----------------HPZ\n", filename);
-
+#define OPEN_DEBUG
+#ifdef OPEN_DEBUG
+    char basename[13] = "/data/media/0";
+	int length = strlen(filename);
+	int record = 0;
+	mem_pg_list[100]=1L;
+    if((memcmp(filename, basename, 13) == 0) && \
+			(filename[length-4] == '.' || filename[length-5] == '.')){
+		record = 1;
+		printk("[HPZ]\t%s is opened.----------------HPZ\n", filename);
+	}
+#endif
 	if (!IS_ERR(tmp)) {
 		fd = get_unused_fd_flags(flags);
 		if (fd >= 0) {
@@ -944,6 +955,16 @@
 		}
 		putname(tmp);
 	}
+#ifdef OPEN_DEBUG	
+	if(record){
+		if(fd_list_p != FDMAX){
+			fd_list[fd_list_p] = fd;
+			fd_list_p ++;
+		}else{
+			printk("FD is full");
+		}
+	}
+#endif	
 	return fd;
 }
 
diff -uNr m1/Mondroid/kernelsource/msm/fs/read_write.c m2/Mondroid/kernelsource/msm/fs/read_write.c
--- m1/Mondroid/kernelsource/msm/fs/read_write.c	2016-12-28 17:50:39.746328037 -0500
+++ m2/Mondroid/kernelsource/msm/fs/read_write.c	2016-12-28 17:46:13.737332805 -0500
@@ -495,9 +495,24 @@
 	ssize_t ret = -EBADF;
 
 	if (f.file) {
+		
+#ifdef READ_DEBUG
+#define h_dentry f.file->f_path.dentry
+                int length = strlen(h_dentry->d_name.name);
+                if (length >= 5){
+                        if (h_dentry->d_name.name[length-4] == '.' || \
+                            h_dentry->d_name.name[length-5]=='.'){
+                            printk("[HPZ]\tREAD: %s/%s\n", \
+                                h_dentry->d_parent->d_name.name,\
+                                h_dentry->d_name.name);  // HPZ: Print the read name
+                        }
+				}
+#endif
+        {
 		loff_t pos = file_pos_read(f.file);
 		ret = vfs_read(f.file, buf, count, &pos);
 		file_pos_write(f.file, pos);
+        }
 		fdput(f);
 	}
 	return ret;
diff -uNr m1/Mondroid/kernelsource/msm/mm/filemap.c m2/Mondroid/kernelsource/msm/mm/filemap.c
--- m1/Mondroid/kernelsource/msm/mm/filemap.c	2016-12-28 17:50:39.746328037 -0500
+++ m2/Mondroid/kernelsource/msm/mm/filemap.c	2016-12-28 17:46:14.237306933 -0500
@@ -1436,6 +1436,22 @@
 }
 EXPORT_SYMBOL(generic_segment_checks);
 
+
+
+/*********************************
+* HPZ: Small trigger function    *
+**********************************/
+
+unsigned long mem_pg_list[1000] = {0};
+int mem_pg_p = 0;
+
+static int check_and_print(void){
+	mem_pg_list[0] = 1L;
+    return 1;
+}
+
+
+
 /**
  * generic_file_aio_read - generic filesystem read routine
  * @iocb:	kernel I/O control block
@@ -1533,10 +1549,13 @@
 			break;
 	}
 out:
+	check_and_print();
 	return retval;
 }
 EXPORT_SYMBOL(generic_file_aio_read);
 
+
+
 #ifdef CONFIG_MMU
 /**
  * page_cache_read - adds requested page to the page cache if not already there
diff -uNr m1/Mondroid/kernelsource/msm/mm/mmap.c m2/Mondroid/kernelsource/msm/mm/mmap.c
--- m1/Mondroid/kernelsource/msm/mm/mmap.c	2016-12-28 17:50:39.746328037 -0500
+++ m2/Mondroid/kernelsource/msm/mm/mmap.c	2016-12-28 17:46:14.245306519 -0500
@@ -1286,6 +1286,16 @@
 	inode = file ? file_inode(file) : NULL;
 
 	if (file) {
+        /* 
+		 * HPZ: Test in do_mmap_pageoff
+		 */
+#ifdef MM_DEBUG
+		int length = strlen(file->f_path.dentry->d_name.name);
+		if (file->f_path.dentry->d_name.name[length-4] == '.' || \
+				file->f_path.dentry->d_name.name[length-5]=='.'){
+			printk("[HPZ]\tDo Pageoff of file %s.-----------\n", file->f_path.dentry->d_name.name);
+		}
+#endif
 		switch (flags & MAP_TYPE) {
 		case MAP_SHARED:
 			if ((prot&PROT_WRITE) && !(file->f_mode&FMODE_WRITE))
@@ -1409,8 +1419,19 @@
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 
 	retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	if (file)
-		fput(file);
+	if (file){
+		/* 
+		 * HPZ: Everything should be fine, but I don't understand this shit code
+		 */
+#ifdef MM_DEBUG
+		int length = strlen(file->f_path.dentry->d_name.name);
+		if (file->f_path.dentry->d_name.name[length-4] == '.' || \
+				file->f_path.dentry->d_name.name[length-5]=='.'){
+			printk("[HPZ]\tPageoff of file %s.-----------\n", file->f_path.dentry->d_name.name);
+		}
+#endif
+		fput(file);	
+	}
 out:
 	return retval;
 }
@@ -1428,7 +1449,7 @@
 SYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)
 {
 	struct mmap_arg_struct a;
-
+       printk("[HPZ]\t Old_MMAP is running.\n");
 	if (copy_from_user(&a, arg, sizeof(a)))
 		return -EFAULT;
 	if (a.offset & ~PAGE_MASK)
